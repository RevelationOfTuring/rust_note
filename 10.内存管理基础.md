## 10.内存管理基础

### 10.1 堆和栈

一个进程在执行的时候，它所占用的内存的**虚拟地址空间**一般被分割成好几个区域，我们称为“段”( Segment)。 常见的几个段如下 。

- 代码段：编译后**机器码**存在的区域，一般该段是只读的；
- bss段：存放**未初始化**的**全局变量**和**静态变量**的区域；
- 数据段：存放**已初始化**的**全局变量**和**静态变量**的区域；
- 函数调用栈(stack)：存放**函数参数**、**局部变量**以及其他函数调用相关信息的区域；（LIFO，后入先出）
- 堆(heap)：存放动态分配内存的区域。

堆和栈不一样，从堆上**分配**和**重新分配**块没有固定模式，用户可以在**任何时候**分配和释放它 。 这就使得跟踪那部分堆已经被分配，哪部分已经被释放变得异常复杂。

堆是**动态分配**的内存，是**无序**的 。 每个线程都有一个栈，但是每一个应用程序通常都**只有一个堆**。 在堆上的变量必须要**手动释放**，不存在**作用域**的问题。



一般的**操作系统**提供了堆上分配和释放内存的系统调用，可是用户不会去直接使用这个系统调用，而是使用封装的更好的内存分配器。如：C中就提供了`malloc`和`free`两个函数来管理堆内存。

#### 10.1.1 堆和栈的一些开发常识

- 栈上的局部变量在推出当前作用域时会自动释放；
- 堆上分配的空间没有作用域，不会自动释放；
- 一般栈上分配的空间大小在**编译阶段**是可以确定的；
- 栈有一个确定的最大长度，超过则会**栈溢出**（stack overflow）；
- 堆的空间要更大一些。如果堆上内存耗尽了，就会出现**内存分配不足**（out of memory）。

### 10.2 段错误

回忆一下Rust官网对Rust的介绍：

```shell
Rust is a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.
```

其中的segfaults是“segmentation fault”的缩写形式，翻译过来就是段错误。

那什么是段错误呢？

进程空间中的每个段通过**硬件MMU映射**到真正的物理空间，该映射过程中还可以给不同的段设置不同的**访问权限**，比如：代码段就是只读的。

进程在running的过程中，如果违反了这些权限，CPU会直接报一个**硬件异常**到操作系统的内核。一般内核会向对应的进程发送一条**信号**，如果该进程没有实现自己特殊的信号处理函数，那这个进程一般就会非正常退出。

在C/C++里面制造segfault是很容易的。程序员需要非常小心才能避免这种错误——这也是那么多代码标准存在的原因。

另一类规避segfault的方法就是**自动垃圾回收机制**。具有GC的编程语言路指针的能力被**大幅限制**，内存的分配与释放都在一个runtime中被严格管理。这么做也是要付出代价的——效率。

Rust的设计目标是在不使用自动垃圾回收机制的前提下避免产生segfault。这在通用编程语言中，是独一无二的。

### 10.3 内存安全

谈到Rust经常会提到“内存安全”（Memory safety），看一些内存不安全的例子：

- 空指针：**解引用**空指针是不安全的，并且会在大部分平台上产生segfault；
- 野指针：指未初始化的指针。它其中的值取决于该位置之前遗留下的是什么值。对它解引用，可能会造成segfault，也可能不会，全看命；
- 悬空指针：指内存空间在被释放后，其对应指针仍在使用。跟野指针类似——可会读写已经不属于这个指针的内容；
- 使用未初始化内存：不单单是指针，使用任何不初始化的类型都是极为危险的，因为“脏内存”；
- 非法释放：对同一个指针释放两次，就会出内存错误。如果指针并不是**内存分配器**返回的值，对其释放也是极危险的；
- 执行非法函数指针：如果一个函数指针不是准确地指向一个函数地址，那么调用这个函数指针会导致一段随机数据被当成指令执行，危险；
- 数据竞争：**并发**场景下，针对同一块内存同时读写且没有同步措施。

以上问题并不是在发生的时候，就会立即终止进程。如果没有直接触发**core dump**，程序可能会带病运行，进而导致结果一直有bug但无法找到原因。

### 10.4 内存泄漏/内存耗尽

在Rust的设计中，**内存泄漏**以及**内存耗尽**并不算在“内存安全”的范畴内。

内存泄漏和内存耗尽显然是也是bug，但是它不会直接导致严重后果，解决方法也各不一样。

当出现内存耗尽时，Rust的行为依然是**确定**和**可控**的。（目前版本内存耗尽则发生panic）

### 10.5 panic与core dump的区别

panic是发生不可恢复的错误后，程序**主动执行**的一种错误处理机制；而core dump则是程序失控后触发了操作系统的保护机制而**被动退出**。

发生panic的时候，就是确定性的**第一现场**。程序员可以根据call stack信息找到事发地点，然后修复。

panic是防止更严重内存安全错误的重要机制。